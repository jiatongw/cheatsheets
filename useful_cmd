常用命令:

look for a process:
	ps ax | grep test.py

run python in backend:
	python test.py &

look for a process in a given port:
	lsof -i:port number


mongo connection failed solution:

	sudo rm /var/lib/mongodb/mongod.lock
	sudo mongod --repair --dbpath /var/lib/mongodb
	sudo mongod --fork --logpath /var/lib/mongodb/mongodb.log --dbpath /var/lib/mongodb 
	sudo service mongodb start

Git submodule process:
1. add submodule: git submodule add   source_url   dest_dir
2. modify .gitmodules file to use a sprcific branch (i.e. add a branch information: branch = vmware-1.15.0)
3. update submodule: git submodule update --init --recursive --remote

Git delete the first commit: 
	git rebase -i —-root 

docker rm all containers:
	docker rm $(docker rm -a -q) (docker rm -a -q) will list all container ID


琐碎知识点:

URI和URL的区别
URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径。
比如：URI就像身份证，而URL则是这个人的家庭住址。是URI但不是URL的例子：urn:isbn:0-486-27557-4，这个是一本书的isbn，可以唯一标识这本书，
更确切说这个是URN。总的来说，locators are also identifiers, so every URL is also a URI, but there are URIs which are not URLs

vim 中 :x 和 :wq 的真正区别:
:wq  强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。
:x   写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。
 
这两者一般情况下没什么不一样，但是在编程方面，对编辑源文件可能会产生重要影响。因为文件即使没有修改，":wq"强制更新文件的修改时间，
这样会让make编译整个项目时以为文件被修改过了，然后就得重新编译链接生成可执行文件。这可能会产生让人误解的后果，当然也产生了不必要的系统资源花销。

kubenetes cluster 没起来，很可能是kubelet没起来，这个时候要查看systemd log, 和kubelet的log。syslog的位置在/var/logs/syslog。或者用systemctl status kubelet来查看kubelet状态，如果没起来，有一个可能是Kubeadm没执行。也有可能是container的repo名字没对上。这时候就要查一下kubeadm的config和kubeadm的log。

静态编译与动态编译的区别：
静态编译就是在编译时，把所有模块都编译进可执行文件里，当启动这个可执行文件时，所有模块都被加载进来；
动态编译是将应用程序需要的模块都编译成动态链接库，启动程序（初始化）时，这些模块不会被加载，运行时用到哪个模块就调用哪个
一般建议用静态编译
runC是一个遵循OCI标准的用来运行容器的命令行工具(CLI Tool)，它也是一个Runtime的实现


Golang init函数的主要作用：

初始化不能采用初始化表达式初始化的变量。
程序运行前的注册。
实现sync.Once功能。
其他
init函数的主要特点：

init函数先于main函数自动执行，不能被其他函数调用；
init函数没有输入参数、返回值；
每个包可以有多个init函数；
包的每个源文件也可以有多个init函数，这点比较特殊；
同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。
不同包的init函数按照包导入的依赖关系决定执行顺序。
golang程序初始化



golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：

初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见golang变量的初始化）；
初始化包作用域的变量（该作用域的变量的初始化也并非按照“从上到下、从左到右”的顺序，runtime解析变量依赖关系，没有依赖的变量最先初始化，参见golang变量的初始化）；
执行包的init函数；

特殊变量列表
变量
含义

$0 当前脚本的文件名

$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。

$# 传递给脚本或函数的参数个数。

$* 传递给脚本或函数的所有参数。

$@ 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。

$? 上个命令的退出状态，或函数的返回值。

$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。

$* 和 $@ 的区别
$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。
但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数

Python self :
self在定义时需要定义，但是在调用时会自动传入。
self的名字并不是规定死的，但是最好还是按照约定是用self
self总是指调用时的类的实例, 不是类本身。

Go Context
比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文。

切片的长度是切片中元素的数量
切片的容量是从创建切片的索引开始的底层数组中元素的数量
切片是可索引的，并且可以由len()方法获取长度，切片提供了计算容量的方法cap()，可以测量切片最长可以达到多少。
切片实际的是获取数组的某一部分，len切片<=cap切片<=len数组

在shell中

'>'  为创建: echo "hello shell"  > out.txt
'>>' 为追加: echo "hello shell"  >> out.txt

当out.txt 文本不存在时,'>'与'>>'都会默认创建out.txt文本，并将hello shell 字符串保存到out.txt中

当out.txt文本存在时，'>'会将out.txt文本中的内容清空，并将hello shell 字符串存, 而'>>'会将 hello shell追加保存到out.txt的末尾


bash script可以当做binary来执行。比如bazel.sh，当去掉文件后缀.sh，就可以./bazel


golang build in container example:
docker run --rm \
-v "${PWD}:/go/src/sigs.k8s.io/kind" \
-v "${PWD}/bin:/go/bin" \
-w "/go/src/sigs.k8s.io/kind" \
--env CGO_ENABLED=0 \
--env GOOS=${GOOS:-linux} \
--env GOARCH=${GOARCH:-amd64} \
--env GO111MODULE=on \
golang:${golangVersion} \
go build -a -ldflags '-extldflags "-static"' -o /go/bin/kind


special charactors

#! /bin/sh
echo '$#' $#
echo '$@' $@
echo '$?' $?

run as ./test.sh 1 2 3 4

output will be:
$#  4
$@  1 2 3 4
$?  0

$# means number of arguments. Answer is 3
$@ means what parameters were passed. Answer is 1 2 3
$? means was last command successful. Answer is 0 which means 'yes'


python 初始化二维数组：
如果是 B = [[0]*3]*4来创建二维数组， 那么
>>> B
[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
但是，B[0][1] = 2，输出：
>>> B
[[0, 2, 0], [0, 2, 0], [0, 2, 0], [0, 2, 0]]

按照B = [[0]*3]*4来创建二维数组只是4个指向这个空列表元素的引用,修改任何一个元素都会改变整个列表

在Python中创建二维数组应该这样写：
C = [[0]*3 for i in range(4)]
>>> C[0][1] = 2
>>> C
[[0, 2, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]

通用：aList = [[0] * cols for i in range(rows)]

互斥锁 and 读写锁
互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 一次只能一个线程拥有互斥锁，其他线程只有等待
读写锁特点：
1）多个读者可以同时进行读 2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行） 3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
